# -*- coding: utf-8 -*-
"""Smart Data Aggregator Assignment2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11e7_OaDn_MoUeX3xAhu2563mpIWueZTg

# **# Smart Data Aggregator Assignment**

## Overview
In this assignment, we will develop different modules for a Smart Data Aggregator tool that manages and analyzes large sets of user data. This notebook focuses on user data processing using Python's built-in data structures.

# **## Part 1: User Data Processing with Lists**
In this section, we will work with a sample list of user data, where each user is represented as a tuple containing their ID, name, age, and country. The primary goals of this part are to filter out users based on age and country, sort the list of users by age, and identify any duplicate names within the dataset.

**Sample User Data**:
This dataset consists of various users, including their respective user IDs, names, ages, and countries. We will use this data to demonstrate data processing techniques, such as filtering, sorting, and duplicate detection.
"""

# Sample data: (user_id, user_name, age, country)
users = [
    (1, "Alice", 29, "USA"),
    (2, "Bob", 34, "Canada"),
    (3, "Charlie", 28, "UK"),
    (4, "David", 31, "USA"),
    (5, "Eva", 27, "Canada"),
    (6, "Frank", 40, "USA"),
    (7, "Grace", 35, "Canada"),
    (8, "Hannah", 22, "USA"),
    (9, "Ivan", 30, "USA"),
    (10, "Judy", 32, "Canada"),
    (11, "Charlie", 45, "Canada"),
]

"""## 1.1 Function to Filter Users

This function filters out users who are older than 30 years from specific countries (USA and Canada). It returns a list of their names.

**The function works by:**

- Iterating over the list of users.
- Checking if the user's age is greater than 30 and if they belong to either the USA or Canada.
- Collecting the names of the users who meet these criteria.

"""

def filter_users(users):
    filtered_names = [user[1] for user in users if user[2] > 30 and user[3] in ('USA', 'Canada')]
    return filtered_names

"""## 1.2 Function to Sort Users and Find Duplicates

This function sorts the users by age in descending order and identifies any duplicate names within the dataset. It returns:
- A list of the top 10 oldest users.
- A set of duplicate names.

The sorting is done based on the age attribute of each user. Duplicate names are found by checking if the name appears more than once in the user list.

"""

def sort_users_and_find_duplicates(users):
    sorted_users = sorted(users, key=lambda x: x[2], reverse=True)
    top_10_oldest = sorted_users[:10]
    names = [user[1] for user in users]
    duplicates = set(name for name in names if names.count(name) > 1)

    return top_10_oldest, duplicates

"""**### Execution of Functions**

Now, we will execute the functions we defined earlier to filter users and sort them, as well as to find duplicates in the dataset.

"""

filtered_user_names = filter_users(users)
print("Users older than 30 from USA or Canada:", filtered_user_names)
top_old_users, duplicate_names = sort_users_and_find_duplicates(users)
print("Top 10 oldest users:", top_old_users)
print("Duplicate names:", duplicate_names)

"""# **Part 2: Immutable Data Management with Tuples**

In this section, we will work with sample transaction data represented as tuples. The primary goals of this part are to count unique users, find the highest transaction amount, and separate transaction IDs from user IDs.

## 2.1 Set Up the Transaction Data

We will create a sample dataset that includes various transactions. Each transaction is represented as a tuple containing the transaction ID, user ID, amount, and timestamp.


"""

# Sample transaction data: (transaction_id, user_id, amount, timestamp)
transactions = [
    (1, 1, 100.50, "2024-10-01 10:00:00"),
    (2, 2, 200.00, "2024-10-02 11:00:00"),
    (3, 3, 150.75, "2024-10-01 10:30:00"),
    (4, 1, 50.25, "2024-10-03 12:00:00"),
    (5, 4, 300.00, "2024-10-01 09:00:00"),
]

"""## 2.2 Function to Count Unique Users

In this section, we will define a function called `count_unique_users` that calculates the total number of unique users based on their user IDs in the transaction data.

The function works as follows:
- It uses a generator expression to iterate over each transaction in the `transactions` list and extract the user ID (the second element of each tuple).
- These user IDs are collected into a set, which only keeps unique values.
- Finally, we return the length of the set, representing the count of unique users.


"""

def count_unique_users(transactions):
    unique_users = set(transaction[1] for transaction in transactions)
    return len(unique_users)
unique_user_count = count_unique_users(transactions)
print("Total unique users in transactions:", unique_user_count)

"""## 2.3 Function to Find the Highest Transaction

In this section, we will define a function called `highest_transaction` that identifies the transaction with the highest amount. This function will help us quickly find which transaction had the largest value.

The function works as follows:
- We use the built-in `max` function to search through the `transactions` list.
- The `key` argument of the `max` function allows us to specify that we want to compare transactions based on the amount (the third element of each tuple).
- The function returns the transaction tuple that has the highest amount.

"""

def highest_transaction(transactions):
    highest = max(transactions, key=lambda x: x[2])
    return highest
highest_trans = highest_transaction(transactions)
print("Highest transaction:", highest_trans)

"""## 2.4 Function to Separate Transaction IDs and User IDs

In this section, we will create a function called `separate_ids` that separates the transaction IDs from the user IDs in our transaction data.

The function works as follows:
- We use a list comprehension to create a list of transaction IDs. We get the first element (transaction ID) from each tuple in the `transactions` list.
- Similarly, we create another list of user IDs by extracting the second element (user ID) from each tuple.
- Finally, the function returns both lists: one for transaction IDs and one for user IDs.


"""

def separate_ids(transactions):
    transaction_ids = [transaction[0] for transaction in transactions]
    user_ids = [transaction[1] for transaction in transactions]
    return transaction_ids, user_ids

trans_ids, user_ids = separate_ids(transactions)
print("Transaction IDs:", trans_ids)
print("User IDs:", user_ids)

"""# **Part 3: Unique Data Handling with Sets**

In this section, we will work with sets to manage unique user IDs who visited different pages. We will perform operations to find common users, exclusive users, and update user sets accordingly.

## 3.1 Set Up User ID Sets

We will create three sets representing user IDs of visitors to pages A, B, and C. Each set will contain unique user IDs.
"""

# Sample User ID Sets
page_a_visitors = {1, 2, 3, 4, 5}  # User IDs who visited Page A
page_b_visitors = {3, 4, 5, 6, 7}  # User IDs who visited Page B
page_c_visitors = {5, 6, 7, 8, 9}  # User IDs who visited Page C

"""## 3.2 Function to Find Users Who Visited Page A and Page B

This function will return the user IDs that are present in both sets, indicating users who visited both pages.
"""

def users_visited_both(page_a, page_b):
    return page_a.intersection(page_b)
common_visitors = users_visited_both(page_a_visitors, page_b_visitors)
print("Users who visited both Page A and Page B:", common_visitors)

"""## 3.3 Function to Find Users Who Visited Either Page A or Page C, but Not Both

This function will return the user IDs that are in either Page A or Page C but not in both sets.
"""

def users_visited_either_not_both(page_a, page_c):
    return page_a.symmetric_difference(page_c)

exclusive_visitors = users_visited_either_not_both(page_a_visitors, page_c_visitors)
print("Users who visited either Page A or Page C, but not both:", exclusive_visitors)

"""## 3.4 Function to Update Page A Set with New User IDs
This function will add new user IDs to the set for Page A.
"""

def update_page_a(page_a, new_users):
    page_a.update(new_users)

new_visitors = {10, 11}
update_page_a(page_a_visitors, new_visitors)
print("Updated Page A visitors:", page_a_visitors)

"""## 3.5 Function to Remove User IDs from Page B Set
This function will remove specified user IDs from the set for Page B.

"""

def remove_from_page_b(page_b, users_to_remove):
    page_b.difference_update(users_to_remove)

users_to_remove = {3, 4}
remove_from_page_b(page_b_visitors, users_to_remove)
print("Updated Page B visitors after removal:", page_b_visitors)

"""# **Part 4: Data Aggregation with Dictionaries**

In this section, we will work with a dictionary to manage user feedback. Each entry in the dictionary will use the user ID as a key, and the value will be another dictionary containing feedback details, including the rating and comments. We will perform operations to filter and sort this data.

## 4.1 Set Up User Feedback Data

We will create a sample dictionary to represent user feedback. Each key will be a user ID, and the corresponding value will be a nested dictionary containing a rating and comments.
"""

# user feedback data
user_feedback = {
    1: {'rating': 5, 'comments': "Excellent service!"},
    2: {'rating': 3, 'comments': "It was okay."},
    3: {'rating': 4, 'comments': "Very good experience."},
    4: {'rating': 2, 'comments': "Not satisfied."},
    5: {'rating': 4, 'comments': "Good value for money."},
    6: {'rating': 5, 'comments': "Outstanding support!"},
    7: {'rating': 1, 'comments': "Terrible experience."},
    8: {'rating': 4, 'comments': "I liked it a lot."},
    9: {'rating': 3, 'comments': "Average quality."},
    10: {'rating': 5, 'comments': "Will come back again!"}
}

"""## 4.2 Function to Filter Users with Ratings of 4 or Higher
This function will create a new dictionary containing user IDs and their ratings for users who rated 4 or higher.
"""

def filter_high_ratings(feedback):
    high_rated_users = {user_id: details['rating'] for user_id, details in feedback.items() if details['rating'] >= 4}
    return high_rated_users
high_rating_users = filter_high_ratings(user_feedback)
print("Users who rated 4 or higher:", high_rating_users)

"""## 4.3 Function to Sort User Feedback by Rating
This function will sort the original dictionary of user feedback by rating in descending order and return the top 5 users.
"""

def top_rated_users(feedback, top_n=5):
    sorted_users = sorted(feedback.items(), key=lambda x: x[1]['rating'], reverse=True)
    return dict(sorted_users[:top_n])


top_users = top_rated_users(user_feedback)
print("Top 5 users by rating:", top_users)

"""### Sample Feedback Data

We will define two sample dictionaries representing user feedback from different sources.


"""

# Sample user feedback data from different sources
feedback_source1 = {
    1: {'rating': 5, 'comments': "Excellent service!"},
    2: {'rating': 3, 'comments': "It was okay."},
    3: {'rating': 4, 'comments': "Very good experience."}
}

feedback_source2 = {
    2: {'rating': 4, 'comments': "Great improvement."},
    3: {'rating': 2, 'comments': "Not satisfied."},
    4: {'rating': 5, 'comments': "Outstanding service!"}
}

"""## 4.4 Combine Feedback from Multiple Dictionaries

In this section, we will create a function that combines user feedback from multiple dictionaries. If a user appears in more than one dictionary, we will update their rating to the highest one and append their comments.


"""

def combine_feedback(*feedback_dicts):
    combined_feedback = {}

    for feedback in feedback_dicts:
        for user_id, details in feedback.items():
            if user_id in combined_feedback:
                combined_feedback[user_id]['rating'] = max(combined_feedback[user_id]['rating'], details['rating'])
                combined_feedback[user_id]['comments'].append(details['comments'])
            else:
                combined_feedback[user_id] = {
                    'rating': details['rating'],
                    'comments': [details['comments']]
                }

    return combined_feedback

combined_feedback = combine_feedback(feedback_source1, feedback_source2)
print("Combined Feedback:", combined_feedback)

"""## 4.5 Filter Users with Ratings Greater than 3
We will use dictionary comprehension to create a new dictionary containing user IDs and their ratings for users whose ratings are greater than 3.
"""

def filter_users_above_rating(feedback, min_rating=3):
    return {user_id: details['rating'] for user_id, details in feedback.items() if details['rating'] > min_rating}

users_above_rating = filter_users_above_rating(combined_feedback)
print("Users with ratings greater than 3:", users_above_rating)